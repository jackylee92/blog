# Go 垃圾回收

## 回收方式

### 引用记数

通过给对象添加记数器，当记数器为0的时候回收改对象

__优点：__ 

* 回收快，当记数器为0是立刻回收

* 实现简单

* 不需要Stop The Work

__缺点：__

* 无法处理循环依赖，比如 A依赖了B，B又依赖了A，他两的记数器都为1，所以永远不会被回收

* 记数器维护维护成本高

* 当核销一个很大的对象时，性能会下降

### 标记-清除算法

通过"标记"，"清除"两步实现

标记：标记需要回收的垃圾对象

清除：在标记完后，清除标记的对象，释放内存

__优点：__：

* 算法效率高，执行速度快

* 不需要额外的记数器维护，性能成本相对较低

__缺点：__

* 清除后会产生大量的内存碎片，导致程序可能无法为大对象分配内存空间，提前进入下一次的垃圾回收

### 标记-复制算法

将内存分为两块，当第一块使用完后，将其中的不需要垃圾回收的对象复制到另一块内存中，将第一块内存释放，第二块标记为使用

__优点：__

* 标记-移动-释放，整体效率较高

* 不会产生内存碎片问题

__缺点：__

* 内存利用率低，只有原本的一半

* 当可达到对象较多时，复制的成本较高

### 标记-整理算法

结合了标记-清除、标记-复制优势，既不产生碎片化内存、又不压缩一般内存，使用标记初所有可达的对象，将可达的对象移动至内存的一端，然后将可达对象的边界之外的对象清除、内存释放。

__优点：__

* 不会产生内存碎片

* 不会压缩使用的内存空间

__缺点：__

* 标记过程复杂，需要多次遍历，导致SWT时间过长

### 三色标记法

优化标记过程不需要STW，初始化所有对象为白色，通过循环遍历将可达标记为黑色，然后回收所有白色，

步骤

1. 将所有的对象标记为白色

2. 从root出发，将有引用的对象本身标记为灰色，放入队列

3. 从队列中取出灰色，将灰色变为黑色，将灰色的引用对象变为灰色，将这个灰色对象放入队列中

4. 重复上一步，将灰色取出，变为黑色，引用的对象变为灰色，放入队列

5. 直到所有的灰色变为黑色。

6. 回收白色对象

__优点：__

* 不需要暂停整个程序进行垃圾回收

__缺点：__

* 如果程序产生的临时对象速度大于垃圾回收的速度，将导致产生大量需要回收的对象，却垃圾回收的时间变长。

#### 强三色不变性

黑色对象不可以指向白色对象

#### 弱三色不变性

黑色对象可以指向白色对象，但执行的白色对象必须保证有一条灰色对象已经指向它


